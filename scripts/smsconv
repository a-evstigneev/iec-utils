#!/bin/sh

hextoint()
{
	/bin/echo "ibase=16; $1" | bc
}

hextobin()
{
	local binstr 
	local strlen
	local addlen

	binstr=$(/bin/echo "obase=2; ibase=16; $1" | bc) 
	strlen=$(expr length "$binstr")		

	if ! [ $(expr $strlen % 8) -eq 0 ]; then
		if [ $strlen -gt 8 ]; then
			addlen=$(expr $strlen % 8)
		elif [ $strlen -lt 8 ]; then
			addlen=$(expr 8 - $strlen)	
		fi
	
		while [ $addlen -gt 0 ]; do
			binstr=0${binstr}
			addlen=$(($addlen - 1))
		done
	fi

	echo "$binstr"
}

bintohex()
{
	echo $(/bin/echo "obase=16; ibase=2; $1" | bc) 
}

getnumtype()
{
	local numtype
	numtype=$(echo $(hextobin $1) | cut -b 2-4)
	case $numtype in
		"001")
			echo "INTER"
		;;
		"101")
			echo "ALPHANUM"
		;;
	esac
}

getnumber()
{
	local number d1 d2 
	local tmpnum=$1
	local lennum=$(expr length $1)
	
	while [ $lennum -gt 0 ]; do
		d1=$(echo $tmpnum | cut -b 1)
		d2=$(echo $tmpnum | cut -b 2)
		tmpnum=$(echo $tmpnum | cut -b 3-)
		number=${number}${d2}${d1}
		lennum=$(($lennum - 2))
	done
	
	echo ${number%F}
}

smsconv()
{
	local smsinfo

	while read smsinfo; do
		SMSIND=$(echo $smsinfo | sed 's/+CMGL: \([0-9]\{1,\}\),.*/\1/')	

		read PDU
		PDUOLD=$PDU
		
		TP_SCA_LEN=$(hextoint $(echo $PDU | cut -b -2)) # Service Center Address length
			PDU=$(echo $PDU | cut -b 3-)
		
		TP_SCA_TYPE=$(echo $PDU | cut -b -2) # Service Center Address type
			PDU=$(echo $PDU | cut -b 3-)
		
		TP_SCA_NUM=$(echo $PDU | cut -b -$((2*$TP_SCA_LEN - 2))) # Service Center Address number
			PDU=$(echo $PDU | cut -b $((2*$TP_SCA_LEN - 1))-)

		
		TP_TYPE=$(echo $PDU | cut -b -2) # Type PDU 
		TP_UDHI=$(echo $(hextobin $TP_TYPE) | cut -b 2) #User Data Header Indicator
			PDU=$(echo $PDU | cut -b 3-)

		TP_OA_LENGTH=$(hextoint $(echo $PDU | cut -b -2)) # Originating Address length
			PDU=$(echo $PDU | cut -b 3-)

		TP_OA_FORMAT=$(echo $PDU | cut -b -2) # Originating Address format
			PDU=$(echo $PDU | cut -b 3-)

		TP_OA_TYPE=$(getnumtype $TP_OA_FORMAT) # Originating Address type

		case $TP_OA_TYPE in
			"INTER")
				TP_OA_NUM=$(getnumber $(echo $PDU | cut -b -$((1+$TP_OA_LENGTH)))) # Originating Address number
				PDU=$(echo $PDU | cut -b $((2+$TP_OA_LENGTH))-)
			;;
			"ALPHANUM")
				TP_OA_NUM=$(echo $PDU | cut -b -$((2*$TP_OA_LENGTH))) 
				PDU=$(echo $PDU | cut -b $((2*$TP_OA_LENGTH + 1))-)
			;;
		esac
		
		
		TP_PID=$(echo $PDU | cut -b -2) # Protocol identifier
			PDU=$(echo $PDU | cut -b 3-)

		TP_DCS=$(echo $PDU | cut -b -2) # Data Coding Scheme
			PDU=$(echo $PDU | cut -b 3-)

		TP_SCTS=$(echo $PDU | cut -b -14) # Service Centre Time Stamp
			PDU=$(echo $PDU | cut -b 15-)

		TP_UDL=$(echo $PDU | cut -b -2) # User Data Length
			PDU=$(echo $PDU | cut -b 3-)

		case $TP_UDHI in
			"0") 
				TP_UDH=""
			;;
			"1")
				TP_UDH=$(echo $PDU | cut -b -12) # User Data Header
					PDU=$(echo $PDU | cut -b 13-)
				TP_REF_NUM=$(echo $TP_UDH | cut -b 7-8) # CSMS reference number
				TP_TOTAL_PART=$(hextoint $(echo $TP_UDH | cut -b 9-10)) # Total number of parts
				TP_SER_PART=$(hextoint $(echo $TP_UDH | cut -b 11-12)) # This part's number in the sequence
			;;
		esac

		TP_UD=$PDU # User Data

		echo ${SMSIND}:${TP_OA_NUM}:${TP_DCS}:${TP_SCTS}:${TP_REF_NUM}:${TP_TOTAL_PART}:${TP_SER_PART}:${TP_UD}
		TP_OA_NUM=""; TP_DCS=""; TP_SCTS=""; TP_REF_NUM=""; TP_TOTAL_NUM=""; TP_SEQ_NUM=""; TP_UD="";
	done | sort -n -t: -k 7 -k 6 -k 5,5 
}

smsjoin()
{
	local string
		
	while read string; do
		/usr/bin/printf '%s\n' "$string"
	done | 	awk -F: ' # Сортируем, чтобы части текста одной большой СМС шли по порядку 
	BEGIN {

	}
	
	{
		if ($5 == "") {
			printf("%s:%s:%s:%s:%s\n", $1, $2, $3, $4, $8)
			next
		}
		else {
			if (INDEX[$5] == "")
				INDEX[$5]=$1
			else
				INDEX[$5]=INDEX[$5] " " $1
			NUM[$5]=$2
			DCS[$5]=$3
			SCTS[$5]=$4
			TOTALPART[$5]=$6
			CURPART[$5]=CURPART[$5] + 1
			DATA[$5]=DATA[$5]$8
		}
	}
	END {
		for (var in DATA) {
			if (TOTALPART[var] == CURPART[var]) {
				printf("%s:%s:%s:%s:%s\n", INDEX[var], NUM[var], DCS[var], SCTS[var], DATA[var])
			}
		}
	}
' 
}

smsassamble()
{
	local string 
	local tmp_string

	while read string; do
		if echo "$string" | grep -q -e 'OK' -e 'ERROR'; then
			break 
		else
			echo $string
		fi
	done | smsconv | smsjoin	

	echo  $string	
#	if echo "$string" | grep -q -e 'OK' -e 'ERROR'; then
#		/usr/bin/printf '%s\n' "$string"
#	fi
}

gsmdecode()
{
	local sms=$1
	local smslen=$(expr length $sms)
	local pos=2
	local rest=""
	local smsdecode=""
	
	while [ $smslen -gt 0 ]; do
		octet=$(hextobin $(echo $sms | cut -b -2))
		ch=$(echo $octet | cut -b $(($pos))-)${rest} # 7-bit character in binary representation
		rest=$(echo $octet | cut -b -$(($pos - 1)))
		smsdecode=${smsdecode}\\x$(bintohex ${ch})
		pos=$(($pos + 1))
		
		if [ $pos -eq 9 ]; then 
			pos=2
			smsdecode=${smsdecode}\\x$(bintohex ${rest})
			rest=""
		fi
		
		smslen=$(($smslen - 2))
		if [ ! $smslen -eq 0 ]; then
			sms=$(echo $sms | cut -b 3-) 
		fi
	done
	
	/usr/bin/printf '%b\n' "$smsdecode"
}

ucs2decode()
{
	/bin/echo -n -e `/bin/echo $1 | sed -r 's/.{2}/\\\\x&/g'` | /usr/bin/iconv -f UCS-2BE 2>/dev/null
}

#sms1="DAB73B1CD3B9DFF27698A57DBBC3329DFB2D6F8759DAB73B3CD3B9DFF27698A57DBBC3349DFB2D6F8759C1F55AE72CD359D332FDA473BFE5ED308BDE9BC95C37D0591E26D7E7A021"
#sms2="041D043004480430002004220430043D044F002004430440043E043D0438043B0430002004320020044004350447043A04430020043C044F04470438043A"

#gsmdecode $sms1
#ucs2decode $sms2

while read line; do
	/usr/bin/printf '%s\n' "$line"
done | smsassamble
